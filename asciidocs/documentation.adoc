:sourcedir: ../src/main/java
:icons: font
:toc: left
:sectnums:
:imagesdir: ../asciidocs/images

= Dokumentation

== Allgemein

Music Voting ist ein Projekt, mit dem man Musik spielen kann. Hierbei können Lieder zu einer Playlist hinzugefügt werden, geliked werden und nacheinander abgespielt werden. Mit Music Voting wird jedes lahme Event zu einer richtig coolen Party.

== Struktur

image::system.jpeg[,500]


=== Musik hinzufügen

image::mv01.png[,500]

Man kann in das Suchfeld eingeben, nach was für einem Lied bzw. nach welchem Sänger/welcher Sängerin man suchen will.
Klickt man auf den Button mit der Lupe darunter, startet man die Suche.

image::mv2.png[,500]

Es werden die gefundenen Lieder in einer Liste untereinander angezeigt. Die Songs sind in den meisten Fällen die Lyrics Version des Songs, da somit verhindert wird, dass lange Musikvideos mit unnötigen Dialogen oder Teilen, die nicht zum Song gehören hinzugefügt werden können.

Neben jedem Lied befindet sich ein Button mit einem Plussymbol. Klickt man auf diesen Button, fügt man das Lied zu einer Playlist hinzu.



=== Musik abstimmen

image::mv7.jpeg[,500]

Wenn man oben auf den Reiter "Abstimmen" klickt, gelangt man zu der oben angezeigten Seite. Dort werden alle Lieder angezeigt, die sich in der aktuellen Playlist befinden. Neben jedem Lied befindet sich ein Button mit einem Herz. Klickt man auf diesen wird die Like-Anzahl für das Lied erhöht. Die Lieder der Playlist werden nach der Anzahl der Likes sortiert und die Lieder in dieser Reihenfolge abgespielt. So kann man Lieder, die einem gefallen schneller hören.

=== Musik abspielen

image::mv8.png[,500]

Geht man auf diese Seite, muss das Admin Passwort eingegeben werden. Wird das Passwort korrekt eingegeben, gelangt man auf die richtige Seite mit der Playlist, welche man abspielen kann.


image::mv6.png[,500]

Klickt man auf den türkisen Startbutton beginnt die Musik aus der Playlist nacheinander zu spielen. Zusätzlich wird ein neues Fenster geöffnet, welches man links sehen kann. In diesem Fenster öffnet Youtube das Lied, welches gerade gespielt wird. Die Lieder in der Playlist werden je nach Anzahl der Likes sortiert und auch in dieser Reihenfolge abgespielt. Jede Reihe wird von links nach rechts durchgegangen.

Wenn gerade kein Lied in der Playlist ist, wird automatisch ein neuer Song hinzugefügt. Das funktioniert, indem aus einer Datei mit dem Namen **artists.csv**, eine Liste aus 100 verschiedenen Sänger, einer ausgewählt wird und ein random Song von diesem Sänger hinzugefügt wird.

=== Admin Page

Auf die Admin Page gelangt man, wenn man auf den Button Admin links oben klickt:

image::mv3.png[,500]

Um auf die Admin Page zu gelangen, muss man ein Passwort eingeben. Damit verhindert man, dass jede Person Lieder löschen und Titel sperren kann.
Hat man das richtige Passwort eingegeben, gelangt man auf die folgende Seite.


image::mv4_Admin.png[,500]

Auf der Admin Page sieht man alle Lieder, die sich in der Playlist befinden. Möchte man ein Lied davon löschen, kann man auf den Button mit dem Mitkübel neben jedem Lied klicken.

Reicht das Löschen des Liedes nicht aus, kann man ein Lied auch Sperren lassen. Dafür muss man auf den Button mit dem Schloss klicken.

image::mv5.png[,500]

Möchte man nicht nur ein einzelnes Lied, sondern auch gewisse Wörter in Liedtiteln sperren, kann man auf den Reiter "Black List" klicken.


=== QR-Code

image::mv9.png[,500]

Auf dieser Seite wird ein QR-Code angezeigt. Dieser wird automatisch generiert. Wenn jemand diesen scannen will, ohne zuvor das Admin Passwort einzugeben, wird derjenige/diejenige auf diese Seite weitergeleitet:

image::mv10.jpeg[,500]

Gibt man das richtige Passwort ein, kann der angezeigte QR-Code gescanned werden und man gelangt auf die Seite mit dem Namen "Musik hinzufügen":

image::mv11.png[,500]

image::mv01.png[,500]

== Wieso keine Youtube API

Anfangs wurde Music Voting mit der Youtube API umgesetzt. Youtube rechnet mit sogenannten **Quota**. Quota sind eine Einheit, um die kostenlose Verwendung der API zu limitieren. Pro Tag stehen 10 000 Quota zur Verfügung. Die Youtube API wurde für Music Voting verwendet. Um die Links der Youtube Videos zu erhalten, also wurde die search Funktion verwendet. Diese Funktion verrechnet pro Suchanfrage 100 Quota. Wenn man sich eine Party vorstellt, dann wäre es möglich 10 000 / 100 = 100 Suchanfragen durchzuführen.


== Scraping
Für die Suche auf Youtube wurde dann Scraping verwendet.

Library: https://jsoup.org/[Jsoup^]

.Methode: getSearchFromYoutube in Search.java
[source,java]
----
public List<Song> getSearchFromYoutube(String queryTerm) {
        queryTerm += " Lyrics";
        List<Song> songs = new ArrayList<>();
        String baseUrl = "https://www.youtube.com/results?search_query=";

        Document doc = null;
        try {
            doc = Jsoup.connect(baseUrl+queryTerm).get();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        Element body = doc.body();

        String javascript = body.child(15).html();
        JsonObject json = new JsonObject(javascript.substring(19, javascript.length()-1));

        var videoArray = json.getJsonObject("contents").getJsonObject("twoColumnSearchResultsRenderer")
                .getJsonObject("primaryContents").getJsonObject("sectionListRenderer")
                .getJsonArray("contents").getJsonObject(0).getJsonObject("itemSectionRenderer").getJsonArray("contents"); <1>

        for (int i = 0; i < videoArray.size()-1; i++) {
            var video = videoArray.getJsonObject(i).getJsonObject("videoRenderer");
            if(video != null){
                String title = video.getJsonObject("title").getJsonArray("runs").getJsonObject(0).getString("text");
                String thumbnail = video.getJsonObject("thumbnail").getJsonArray("thumbnails").getJsonObject(0).getString("url");
                String videoUrl = "https://www.youtube.com/watch?v="+ video.getString("videoId");

                if(video.getJsonObject("lengthText") != null) //Live Video <2>
                {
                    String durationString = video.getJsonObject("lengthText").getString("simpleText");
                    int duration = convertStringToDuration(durationString); <3>
                    Song newSong = new Song(title,videoUrl, thumbnail, "", null);
                    newSong.setDuration(duration);
                    songs.add(newSong);
                }
            }
        }
        return songs;
    }
----
<1> Es wird das Javascript ausgelesen
<2> Wenn die Länge eines Video nicht bekannt ist handelt es sich um ein Live Video
<3> Konvertiert einen String der die Länge eines Videos erhält in Millisekungen


Wenn jede dieser Suchanfragen ein Lied spielt, welches 3 Minuten läuft, dann könnte man um die 300 Minuten Lieder abspielen. Das entspricht 5 Stunden. Nahc diesen 5 Stunden müsste man entweder anfangen etwas für jede weitere Suchanfrage zu bezahlen, oder auf der Party würde es keine Musik mehr spielen. Beide Ausgänge sind keine Lösung, darum wurde schlussendlich Scraping verwendet.

== Deployment
Das Deployment ist in 2 Scripts aufgeteilt:

* GH-Action -> publish.yaml
* Script am Server -> deploy.sh und deploy_2.sh

=== GH-Actions

Erstellt einen Release

----
name: Publish Release
on:
  push:
    branches:
      - main

permissions:
  contents: write <1>

jobs:
  pipeline:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: 14

      - name: Install dependencies
        working-directory: ./addMusic
        run: npm install

      - name: Build
        working-directory: ./addMusic
        run: npm run build <2>

      - uses: montudor/action-zip@v1
        with:
          args: zip -qq -r addMusic.zip addMusic/dist/addMusic/ <3>

      - name: list dir
        run: ls

      - name: Set up JDK 14
        uses: actions/setup-java@v1
        with:
          java-version: 14

      - name: Build project with Maven
        working-directory: ./server
        run: mvn -B package --file pom.xml <4>

      - uses: montudor/action-zip@v1
        with:
          args: zip -qq -r backend.zip server/target/quarkus-app/

      - name: Release   <5>
        uses: softprops/action-gh-release@v1
        with:
          draft: false
          prerelease: false
          release_name: 'test'
          tag_name: 'v0.0.3'
          files: |
            addMusic.zip
            backend.zip
            server/artists.csv
----

<1> Wird benötigt um einen Release zu veröffentlichen
<2> Angular Build wird aufgerufen dieses wird verpackt und trasformiert in den Dist Ordner gegeben
<3> Dateien werden gezippt
<4> Quarkus App wird zu einem jar
<5> Erstellt einen Release mit den Dateien addMusic, backend und den Artist.csv

=== Script am Server
Es sind 2 scripts, weil manchmal wird falsch gezippt dann braucht man das zweite script.

----
#webseite
cd /var/www

rm -rd addMusic.zip
rm -rd html

wget https://github.com/MusicVoting/MusicVotingV3/releases/latest/download/addMusic.zip
unzip addMusic.zip

mv addMusic html
rm -rd addMusic.zip

#server
cd /home/mvadmin/deployment

rm -rd quarkus-app
rm -rd backend.zip

wget https://github.com/MusicVoting/MusicVotingV3/releases/latest/download/backend.zip
unzip backend.zip

rm -rd backend.zip

cd quarkus-app
wget https://github.com/MusicVoting/MusicVotingV3/releases/latest/download/artists.csv
java -jar quarkus-run.jar
----

----
#webseite
cd /var/www

rm -rd addMusic.zip
rm -rd html

wget https://github.com/MusicVoting/MusicVotingV3/releases/latest/download/addMusic.zip
unzip addMusic.zip

mv addMusic/dist/addMusic/ ../www/html
#mv addMusic html
rm -rd addMusic.zip

#server
cd /home/mvadmin/deployment

rm -rd quarkus-app
rm -rd backend.zip

wget https://github.com/MusicVoting/MusicVotingV3/releases/latest/download/backend.zip
unzip backend.zip

rm -rd backend.zip

cd server/target/quarkus-app
wget https://github.com/MusicVoting/MusicVotingV3/releases/latest/download/artists.csv
java -jar quarkus-run.jar
----

== Authentifizierung

1. Bei Angular wird das Passwort mit md5 verschlüsselt dann an den Server gesendet
    https://de.wikipedia.org/wiki/Message-Digest_Algorithm_5
2. Am Server wird dann das Passwort mit dem im Application.properties verglichen

----
@GET
    @Path("checkPassword/{password}")
    public Response checkPassword(@PathParam("password") String password){
        String adminPass = ConfigProvider.getConfig().getValue("admin.password", String.class);

        if(Objects.equals(adminPass, password)) {
            System.out.println("Pass: " + adminPass);
            return Response.ok().build();
        }
        return Response.status(Response.Status.FORBIDDEN).build();
    }
----

Das Passwort im Application.properties ist auch verschlüsselt.

https://www.md5.cz/


== Weitere Ideen für die Zukunft

1. Verschidene Versionen:

* Karaoke
* Musik Videos
* Tanz
* ...

2. Quarkus Asynchron
3. Websockets anstatt polling
4. Native Jar mit GraalVM
5. Youtube Video auf der Music Abspielen Seite integrieren (Blass im Hintergrund)

MusicVoting Vorgängerprojekt:

image::youtubeVideo.png[,500]
